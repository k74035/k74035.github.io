---
title: "[c] 포인터"
excerpt: "메모장으로 사용"

categories:
  - Linux Programing
  - 
permalink: /linux-programing/linux-3/

date: 2023-09-30
last_modified_at: 2023-09-30
---

```
#include<stdio.h>

extern char** envrion;

int main()
{
  char** var;
  for (var = environ; *var != NULL; ++var)
    printf("%s\n", *var)
  return 0;
}
```
다음은 환경변수를 출력하는 예제이다.
이 코드를 이해하기 위해 우리는 몇 가지 필요한 선행지식이 있다.

# 배열로 문자열 선언
```
char string[] = "hello world";
```
char은 1바이트를 사용하여 문자열을 만든다. 각 문자는 

# 포인터로 문자열 선언 
```
char* string = "hello world";
```
우리는 포인터변수에는 주소 값만이 할당 되는 것을 알고 있다. 
하지만 위의 예제를 보면 마치 포인터 변수에 문자열을 할당한 것 처럼 보일 수 있다.
헷갈리지 않기 위해 다음과 같이 이해한다.
메모리 어딘가에 "hello world"가 할당되고, string(포인터 변수)은 그 문자열의 가장 앞 글자인 'h'의 주소를 포인팅한다.
> *string = 'h'이다.

# 이중포인터
포인터는 주소값을 갖는 변수이다. 이중포인터 또한 주소값을 가지는 변수이다.
다만 그 대상이 포인터의 주소값을 가지는 변수라는 것을 생각한다면 어렵지 않다.
```
int i =10;
int* p = &i;
int** q = &p;
```
p는 포인터 변수이며 변수 i의 주소값을 가진다.
q는 이중포인터 변수이며 포인터 변수 p의 주소값을 가진다.
> *p는 i를 나타내며, *q는 p를 나타낸다.
> 따라서 **q = *p = i 라는 결과를 도출할 수 있다.

# 환경변수 출력

```
#include<stdio.h>

extern char** envrion;

int main()
{
  char** var;
  for (var = environ; *var != NULL; ++var)
    printf("%s\n", *var)
  return 0;
}
```

1. extern 키워드는 변수가 외부에서 정의된 변수임을 나타낸다. char** environ은 문자열 포인터 포인터로 실행 환경 변수를 저장하는 변수이다.
**왜 이중포인터로 선언되어야 하는가?**
environ 변수가 이중 포인터(char**)로 선언된 이유는 환경 변수들이 문자열로 이루어진 배열이기 때문입니다.
환경 변수는 일반적으로 문자열로 구성되며, 이러한 문자열을 저장하려면 문자열 포인터 배열이 필요합니다. 이러한 배열은 char* 타입의 포인터들의 배열이므로, 각 환경 변수를 가리키는 포인터를 저장하기 위해서는 char** 형태의 포인터를 사용해야 합니다.
environ 변수가 char**로 선언되면, 이중 포인터를 사용하여 각 환경 변수의 주소를 저장할 수 있습니다. 각 char* 포인터가 특정 환경 변수를 가리키며, char** 포인터 배열에는 모든 환경 변수의 포인터가 저장되어 있습니다.
즉, environ은 다음과 같은 형태로 구성됩니다:
```
char* environ[] = {
    "변수1=값1",
    "변수2=값2",
    // ...
    NULL // 환경 변수 목록의 끝을 나타내는 NULL 포인터
};
```
따라서 environ은 이중 포인터로 선언되어야 하며, char** 타입의 포인터를 사용하여 환경 변수 목록에 접근할 수 있습니다.

2. for 루프를 사용하여 environ 배열을 순회하고 각 환경 변수를 printf 함수를 사용하여 출력합니다.
