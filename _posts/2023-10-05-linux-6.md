---
title: "PID 확인 실습"
excerpt: "메모장으로 사용"

categories:
  - Linux Programing
  - 
permalink: /linux-programing/linux-6/

date: 2023-10-05
last_modified_at: 2023-10-05
---

# PID와 PPID를 얻어 화면에 출력한다.
리눅스와 유닉스 계열 운영 체제에서 프로세스 ID(Process ID, PID)를 나타내는 데이터 타입으로 pid_t를 사용한다.
C 언어에서 pid_t는 프로세스 ID를 저장하는 데 사용되며, 일반적으로 sys/types.h 또는 unistd.h 헤더 파일에서 정의된다.
pid_t 타입은 정수형이며, 현재 실행 중인 프로세스를 식별하는 데 사용됩니다. 
각 프로세스는 고유한 PID를 가지며, 이를 통해 프로세스 관리 및 통신에 사용됩니다. 
예를 들어, 다른 프로세스를 식별하고 해당 프로세스에 시그널을 보내거나 프로세스 간 통신을 설정하는 데 pid_t가 사용됩니다.
**즉 pi-t는 프로세스 고유의 ID 값을 담기위한 전용 구조체이다.**

그렇다면 PID값을 얻기 위해서는 어떻게 해야할까?

getpid()라는 함수를 이용한다.
getpid() 함수는 유닉스와 유닉스 계열 운영 체제에서 현재 프로세스의 PID(Process ID)를 얻기 위해 사용되는 함수이다. 
getpid() 함수는 보통 unistd.h 헤더 파일에 정의되어 있다.

```
#include<stdio.h>
#include<unistd.h>

int main()
{
  printf("The process ID is %d\n", (int)getpid());
  printf("The parent process ID is %d\n", (int)getppid());
  return 0;
}
```

linux 쉘에서 다음 파일을 생성하고 컴파일하여 실행파일을 만든뒤 실행해보자.

사진

# 프로세스 확인
프로세스 확인은 ps라는 명령어를 이용하여 시스템에서 활성 프로세스의 수를 확인할 수 있다.
cmd창에 ps만 치면 아래와 같은 화면이 나온다.
> 만약 더 다양한 상태를 보고싶다면 ps command에 대해 구글링하면 다양하게 나오니 참고하자.

사진
첫번째 열은 21693 PID이고 두번째 열은 21694 PID 이다.
TTY는 터미널을 나타내며 어느 위치에서 실행되는지 경로와 환경변수가 표시되고 있다.

TIME과 CMD가 있는데 cmd는 말그대로 명령(command)이다.

**"21693 프로세스 cmd가 bash"라는 경우:**

"21693" PID를 가진 프로세스가 "bash" 셸을 실행하고 있는 것을 나타냅니다.
"bash"는 유닉스와 리눅스 시스템에서 많이 사용되는 명령어 셸로, 명령어를 입력하고 실행하는 데 사용됩니다.

**"21694 프로세스 cmd가 ps"라는 경우:**

이것은 "21694" PID를 가진 프로세스가 "ps" 명령어를 실행하고 있는 것을 나타냅니다. "ps"는 현재 실행 중인 프로세스의 목록을 표시하는 명령어로, 실행 중인 프로세스에 대한 정보를 제공합니다.
따라서 두 경우 모두 "cmd" 프로세스가 다른 명령어나 프로그램을 실행하고 있는 것으로 해석됩니다. "bash"의 경우 명령어 셸을 실행하고, "ps"의 경우 현재 실행 중인 프로세스 목록을 표시하고 있습니다.

# 프로세스 종료
'kill'은 프로세스를 종료하는 명령어이다. 
터미널에 'kill'명령어와 프로세스 ID(PID)를 지정하면 지정된 프로세스가 종료된다.

이때 SIGTERM이라는 용어에 대해 알 필요가 있다.
SIGTERM은 유닉스와 리눅스 운영 체제에서 사용되는 시그널(signal) 중 하나로, "Termination Signal"의 약자입니다. 이 시그널은 프로세스에게 종료(terminate) 요청을 보내는 데 사용됩니다. 주로 프로세스를 정상적으로 종료하거나 중단할 때 사용됩니다.

SIGTERM을 받은 프로세스는 종료할 기회를 갖습니다. 프로세스는 일반적으로 현재 진행 중인 작업을 완료하고 종료됩니다. 이는 프로세스가 데이터를 정리하고 파일을 닫는 등의 정리 작업을 수행할 수 있는 기회를 제공합니다. 만약 프로세스가 SIGTERM 시그널을 무시하거나 명시적으로 처리하지 않으면, 일반적으로 시스템은 해당 프로세스를 강제로 종료할 수 있습니다.

SIGTERM은 프로세스를 종료하는 데 사용되는 일반적인 방법이며, 프로세스가 자체적으로 종료할 수 있는 경우에는 사용자나 관리자가 SIGTERM을 보내어 정상적인 종료를 유도하는 것이 좋은 관행입니다. 이를 통해 데이터 손실을 최소화하고 시스템의 안정성을 유지할 수 있습니다.

***자세한 SIGTERM에 관한 내용은 신호처리 내용에서 다시 배우도록 한다***

# 프로세스 생성하는 법

```
#include<stdilb.h>
int main()
{
  int return_value;
  return_value = system("ls -1/");
  return return_value;
}

system() 함수는 주어진 쉘 명령어를 실행하고 그 명령어의 실행 결과를 반환합니다. 이때 반환 값은 해당 명령어가 실행된 후의 종료 상태(exit status)를 나타냅니다.

"the system function returns the exit status of the shell command."
=> system() 함수는 실행된 쉘 명령어의 종료 상태(exit status)를 반환합니다. 종료 상태는 일반적으로 실행된 명령어가 성공적으로 실행되면 0이고, 그 외의 경우에는 다른 값을 가집니다. 이 값을 사용하여 명령어의 성공 또는 실패를 확인할 수 있습니다.

"if the shell itself cannot be run, system returns 123;"
=> 만약 system() 함수가 쉘 자체를 실행할 수 없는 상황이라면, system() 함수는 123을 반환합니다. 이는 쉘 실행에 문제가 있을 때의 특별한 반환 코드입니다. 일반적으로는 이 반환 값은 쉘 실행 문제를 나타내며, 이로 인해 명령어 실행이 실패한 것으로 간주됩니다.

"if another error occurs, system returns -1"
=> 다른 어떤 오류가 발생할 경우에는, system() 함수는 -1을 반환합니다. 이는 시스템 호출 자체에 오류가 있는 경우를 나타냅니다.

요약하면, system() 함수의 반환 값은 다음과 같습니다:

0: 실행된 명령어가 성공적으로 실행됨.
123: 쉘 실행에 문제가 있음.
-1: 시스템 호출 자체에 오류가 있음.
system() 함수를 사용할 때 이러한 반환 값을 확인하여 명령어 실행의 성공 또는 실패를 판단할 수 있습니다.


